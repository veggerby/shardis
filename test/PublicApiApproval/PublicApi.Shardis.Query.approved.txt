[assembly: System.Reflection.AssemblyMetadata("RepositoryUrl", "https://github.com/veggerby/shardis")]
[assembly: System.Resources.NeutralResourcesLanguage("en")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("Shardis.Query.EntityFrameworkCore")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("Shardis.Query.InMemory")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("Shardis.Query.Tests")]
namespace Shardis.Query.Diagnostics
{
    public interface IAdaptivePagingObserver
    {
        void OnFinalPageSize(int shardId, int finalSize, int totalDecisions);
        void OnOscillationDetected(int shardId, int decisionsInWindow, System.TimeSpan window);
        void OnPageDecision(int shardId, int previousSize, int nextSize, System.TimeSpan lastBatchLatency);
    }
    public interface IQueryMetricsObserver
    {
        void OnCanceled();
        void OnCompleted();
        void OnItemsProduced(int shardId, int count);
        void OnShardStart(int shardId);
        void OnShardStop(int shardId);
    }
    public interface IShardisQueryMetrics
    {
        void RecordQueryMergeLatency(double milliseconds, in Shardis.Query.Diagnostics.QueryMetricTags tags);
    }
    public sealed class MetricShardisQueryMetrics : Shardis.Query.Diagnostics.IShardisQueryMetrics
    {
        public MetricShardisQueryMetrics() { }
        public void RecordQueryMergeLatency(double milliseconds, in Shardis.Query.Diagnostics.QueryMetricTags tags) { }
    }
    public sealed class NoopAdaptivePagingObserver : Shardis.Query.Diagnostics.IAdaptivePagingObserver
    {
        public static readonly Shardis.Query.Diagnostics.IAdaptivePagingObserver Instance;
        public void OnFinalPageSize(int shardId, int finalSize, int totalDecisions) { }
        public void OnOscillationDetected(int shardId, int decisionsInWindow, System.TimeSpan window) { }
        public void OnPageDecision(int shardId, int previousSize, int nextSize, System.TimeSpan lastBatchLatency) { }
    }
    public sealed class NoopQueryMetricsObserver : Shardis.Query.Diagnostics.IQueryMetricsObserver
    {
        public static readonly Shardis.Query.Diagnostics.IQueryMetricsObserver Instance;
        public void OnCanceled() { }
        public void OnCompleted() { }
        public void OnItemsProduced(int shardId, int count) { }
        public void OnShardStart(int shardId) { }
        public void OnShardStop(int shardId) { }
    }
    public sealed class NoopShardisQueryMetrics : Shardis.Query.Diagnostics.IShardisQueryMetrics
    {
        public static readonly Shardis.Query.Diagnostics.IShardisQueryMetrics Instance;
        public void RecordQueryMergeLatency(double milliseconds, in Shardis.Query.Diagnostics.QueryMetricTags tags) { }
    }
    public readonly struct QueryMetricTags
    {
        public readonly int ChannelCapacity;
        public readonly string? DbSystem;
        public readonly string? FailureMode;
        public readonly int FanoutConcurrency;
        public readonly string? MergeStrategy;
        public readonly string? OrderingBuffered;
        public readonly string? Provider;
        public readonly string? ResultStatus;
        public readonly string? RootType;
        public readonly int ShardCount;
        public readonly int TargetShardCount;
        public QueryMetricTags(string? dbSystem, string? provider, int shardCount, int targetShardCount, string? mergeStrategy, string? orderingBuffered, int fanoutConcurrency, int channelCapacity, string? failureMode, string? resultStatus, string? rootType) { }
    }
}
namespace Shardis.Query.Execution.FailureHandling
{
    public sealed class BestEffortFailureStrategy : Shardis.Query.Execution.FailureHandling.IShardQueryFailureStrategy
    {
        public static readonly Shardis.Query.Execution.FailureHandling.BestEffortFailureStrategy Instance;
        public void FinalizeOrThrow(int totalShards) { }
        public bool OnShardException(System.Exception ex, int shardIndex) { }
        public void OnShardSuccess() { }
    }
    public sealed class FailFastFailureStrategy : Shardis.Query.Execution.FailureHandling.IShardQueryFailureStrategy
    {
        public static readonly Shardis.Query.Execution.FailureHandling.FailFastFailureStrategy Instance;
        public bool OnShardException(System.Exception ex, int shardIndex) { }
    }
    public interface IShardQueryFailureStrategy
    {
        bool OnShardException(System.Exception ex, int shardIndex);
    }
}
namespace Shardis.Query.Execution
{
    public interface IShardQueryExecutor
    {
        Shardis.Query.IShardQueryCapabilities Capabilities { get; }
        System.Collections.Generic.IAsyncEnumerable<TResult> ExecuteAsync<TResult>(Shardis.Query.QueryModel model, System.Threading.CancellationToken ct = default);
    }
}
namespace Shardis.Query
{
    public interface IShardQueryCapabilities
    {
        bool SupportsOrdering { get; }
        bool SupportsPagination { get; }
    }
    public interface IShardQueryClient
    {
        Shardis.Query.IShardQueryable<T> Query<T>();
        Shardis.Query.IShardQueryable<TResult> Query<T, TResult>(System.Linq.Expressions.Expression<System.Func<T, bool>>? where = null, System.Linq.Expressions.Expression<System.Func<T, TResult>>? select = null);
    }
    public interface IShardQueryable<out T> : System.Collections.Generic.IAsyncEnumerable<T>
    {
        Shardis.Query.Execution.IShardQueryExecutor Executor { get; }
        Shardis.Query.QueryModel Model { get; }
    }
    public static class OrderedMergeHelper
    {
        public static System.Collections.Generic.IAsyncEnumerable<T> Merge<T, TKey>(System.Collections.Generic.IEnumerable<System.Collections.Generic.IAsyncEnumerable<T>> sources, System.Func<T, TKey> keySelector, System.Threading.CancellationToken ct = default) { }
        public static System.Collections.Generic.IAsyncEnumerable<T> MergeStreaming<T, TKey>(System.Collections.Generic.IReadOnlyList<System.Collections.Generic.IAsyncEnumerable<T>> sources, System.Func<T, TKey> keySelector, System.Collections.Generic.IComparer<TKey>? comparer = null, bool descending = false, System.Threading.CancellationToken ct = default) { }
    }
    public static class QueryClientServiceCollectionExtensions
    {
        public static Microsoft.Extensions.DependencyInjection.IServiceCollection AddShardisQueryClient(this Microsoft.Extensions.DependencyInjection.IServiceCollection services) { }
    }
    public sealed class QueryModel
    {
        public System.Linq.Expressions.LambdaExpression? Select { get; }
        public System.Type SourceType { get; }
        public System.Collections.Generic.IReadOnlyList<Shardis.Model.ShardId>? TargetShards { get; }
        public System.Collections.Generic.IReadOnlyList<System.Linq.Expressions.LambdaExpression> Where { get; }
        public Shardis.Query.QueryModel WithSelect(System.Linq.Expressions.LambdaExpression projector) { }
        public Shardis.Query.QueryModel WithTargetShards(System.Collections.Generic.IReadOnlyList<Shardis.Model.ShardId>? ids) { }
        public Shardis.Query.QueryModel WithWhere(System.Linq.Expressions.LambdaExpression predicate) { }
        public static Shardis.Query.QueryModel Create(System.Type sourceType) { }
    }
    public static class ShardQuery
    {
        public static Shardis.Query.IShardQueryable<T> For<T>(Shardis.Query.Execution.IShardQueryExecutor executor) { }
    }
    public sealed class ShardQueryClient : Shardis.Query.IShardQueryClient
    {
        public ShardQueryClient(Shardis.Query.Execution.IShardQueryExecutor executor) { }
        public Shardis.Query.IShardQueryable<T> Query<T>() { }
        public Shardis.Query.IShardQueryable<TResult> Query<T, TResult>(System.Linq.Expressions.Expression<System.Func<T, bool>>? where = null, System.Linq.Expressions.Expression<System.Func<T, TResult>>? select = null) { }
    }
    public static class ShardQueryExecutorExtensions
    {
        public static Shardis.Query.IShardQueryable<T> Query<T>(this Shardis.Query.Execution.IShardQueryExecutor executor) { }
        public static Shardis.Query.IShardQueryable<TResult> Query<T, TResult>(this Shardis.Query.Execution.IShardQueryExecutor executor, System.Linq.Expressions.Expression<System.Func<T, bool>>? where = null, System.Linq.Expressions.Expression<System.Func<T, TResult>>? select = null) { }
    }
    public static class ShardQueryExplainExtensions
    {
        public static Shardis.Query.ShardQueryPlan Explain<T>(this Shardis.Query.IShardQueryable<T> query, System.Threading.CancellationToken ct = default) { }
    }
    public readonly struct ShardQueryPlan : System.IEquatable<Shardis.Query.ShardQueryPlan>
    {
        public ShardQueryPlan(string Source, int PredicateCount, bool HasProjection, bool SupportsOrdering, bool SupportsPagination) { }
        public bool HasProjection { get; init; }
        public int PredicateCount { get; init; }
        public string Source { get; init; }
        public bool SupportsOrdering { get; init; }
        public bool SupportsPagination { get; init; }
    }
    public static class ShardQueryableConsumptionExtensions
    {
        public static System.Collections.Generic.IAsyncEnumerable<T> ToAsyncEnumerable<T>(this Shardis.Query.IShardQueryable<T> source, System.Threading.CancellationToken ct = default) { }
        public static System.Threading.Tasks.Task<System.Collections.Generic.List<T>> ToListAsync<T>(this Shardis.Query.IShardQueryable<T> source, System.Threading.CancellationToken ct = default) { }
    }
    public static class ShardQueryableExtensions
    {
        public static Shardis.Query.IShardQueryable<T> Where<T>(this Shardis.Query.IShardQueryable<T> source, System.Linq.Expressions.Expression<System.Func<T, bool>> predicate) { }
    }
    public static class ShardQueryableOrderingGuards
    {
        public static Shardis.Query.IShardQueryable<T> OrderBy<T, TKey>(this Shardis.Query.IShardQueryable<T> source, System.Linq.Expressions.Expression<System.Func<T, TKey>> _) { }
        public static Shardis.Query.IShardQueryable<T> OrderByDescending<T, TKey>(this Shardis.Query.IShardQueryable<T> source, System.Linq.Expressions.Expression<System.Func<T, TKey>> _) { }
        public static Shardis.Query.IShardQueryable<T> ThenBy<T, TKey>(this Shardis.Query.IShardQueryable<T> source, System.Linq.Expressions.Expression<System.Func<T, TKey>> _) { }
        public static Shardis.Query.IShardQueryable<T> ThenByDescending<T, TKey>(this Shardis.Query.IShardQueryable<T> source, System.Linq.Expressions.Expression<System.Func<T, TKey>> _) { }
    }
    public static class ShardQueryableSelectExtensions
    {
        public static Shardis.Query.IShardQueryable<TResult> Select<T, TResult>(this Shardis.Query.IShardQueryable<T> source, System.Linq.Expressions.Expression<System.Func<T, TResult>> selector) { }
    }
    public static class ShardQueryableTargetingExtensions
    {
        public static Shardis.Query.IShardQueryable<T> WhereShard<T>(this Shardis.Query.IShardQueryable<T> source, Shardis.Model.ShardId id) { }
        public static Shardis.Query.IShardQueryable<T> WhereShard<T>(this Shardis.Query.IShardQueryable<T> source, params Shardis.Model.ShardId[] ids) { }
    }
    public static class ShardQueryableTerminalExtensions
    {
        public static System.Threading.Tasks.Task<bool> AnyAsync<T>(this Shardis.Query.IShardQueryable<T> source, System.Threading.CancellationToken ct = default) { }
        public static System.Threading.Tasks.Task<long> CountAsync<T>(this Shardis.Query.IShardQueryable<T> source, System.Threading.CancellationToken ct = default) { }
        public static System.Threading.Tasks.Task<T?> FirstOrDefaultAsync<T>(this Shardis.Query.IShardQueryable<T> source, System.Threading.CancellationToken ct = default) { }
    }
    public static class UnorderedMergeHelper
    {
        public static System.Collections.Generic.IAsyncEnumerable<object> Merge(System.Collections.Generic.IEnumerable<System.Collections.Generic.IAsyncEnumerable<object>> sources, System.Threading.CancellationToken ct = default, int? channelCapacity = default) { }
    }
}
namespace Shardis.Query.Internals
{
    public static class UnorderedMerge
    {
        public static System.Collections.Generic.IAsyncEnumerable<object> Merge(System.Collections.Generic.IEnumerable<System.Collections.Generic.IAsyncEnumerable<object>> sources, System.Threading.CancellationToken ct = default, int? channelCapacity = default) { }
    }
}